continue
    user_id = token.gsub('user-id:', '')
    user_id = token.gsub('user-id:', '').to_i
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
continue
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
continue
User.all
User
    User.find user_id
    user_id = token.gsub('user-id:', '').to_i
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
continue
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
request.env["HTTP_AUTHORIZATION"]
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
continue
exit
    User.find user_id
    user_id = token.gsub('user-id:', '').to_i
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
request.env["HTTP_AUTHORIZATION"]
continue
request.env["HTTP_AUTHORIZATION"]
crypt.decrypt_and_verify "onA70zPfqj1BtVgIpvFa19JaSb49swOaMJ3FS2JsZictTnND0HH51xsONnu1GFEpRPhFyfh--X7FCrplzLXIEUCi9--FRquuo6oP4lU88VustDs2Q=="
crypt
request.env["HTTP_AUTHORIZATION"]
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
token.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
token.decrypt request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
token.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
token.decrypt request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
continue
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
continue
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    user_id = token.gsub('user-id:', '').to_i
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
 request.env["HTTP_AUTHORIZATION"] =  request.env["HTTP_AUTHORIZATION"].to_s
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
 request.env["HTTP_AUTHORIZATION"] =  request.env["HTTP_AUTHORIZATION"].to_s
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
continue
            { user:, token: }
            context[:session][:token] = token
            token = crypt.encrypt_and_sign("user-id:#{user.id}")
user.id
user
continue
User.all
    User.find user_id
    user_id = token.gsub('user-id:', '').to_i
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
continue
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
 request.env["HTTP_AUTHORIZATION"] == "AMDQDEJTNZCqi4Z3i9mgioj1suM3wR1VnMCor4cdeNpIk6l64p+nrW6DRtGID2g9HWge4fES--XyNzVWFEhC3qk4x5--JQCq1Y+bJtJXq9roirYLGg=="
 request.env["HTTP_AUTHORIZATION"] 
crypt.decrypt_and_verify "AMDQDEJTNZCqi4Z3i9mgioj1suM3wR1VnMCor4cdeNpIk6l64p+nrW6DRtGID2g9HWge4fES--XyNzVWFEhC3qk4x5--JQCq1Y+bJtJXq9roirYLGg=="
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
crypt.decrypt_and_verify "AMDQDEJTNZCqi4Z3i9mgioj1suM3wR1VnMCor4cdeNpIk6l64p+nrW6DRtGID2g9HWge4fES--XyNzVWFEhC3qk4x5--JQCq1Y+bJtJXq9roirYLGg=="
crypt
continue
crypt
crypt.decrypt_and_verify "AMDQDEJTNZCqi4Z3i9mgioj1suM3wR1VnMCor4cdeNpIk6l64p+nrW6DRtGID2g9HWge4fES--XyNzVWFEhC3qk4x5--JQCq1Y+bJtJXq9roirYLGg=="
token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
request.env["HTTP_AUTHORIZATION"] = request.env["HTTP_AUTHORIZATION"].to_s
continue
    user_id = JWT.decode request.env["HTTP_AUTHORIZATION"], nil, false
continue
    user_id = JWT.decode request.env["HTTP_AUTHORIZATION"], nil, false
request.env["HTTP_AUTHORIZATION"]
continue
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..32))
request.env
request.env.headers
request.headers
request
header
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
ecrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
continue
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"].to_s
request.env["HTTP_AUTHORIZATION"]
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
request.env["HTTP_AUTHORIZATION"]
    token = crypt.decrypt_and_verify(request.env["HTTP_AUTHORIZATION"])
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
request.env["HTTP_AUTHORIZATION"]
continue
exit
    token = crypt.decrypt_and_verify(request.env["HTTP_AUTHORIZATION"])
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
request.env["HTTP_AUTHORIZATION"]
    token = crypt.decrypt_and_verify(request.env["HTTP_AUTHORIZATION"])
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
request.env["HTTP_AUTHORIZATION"] 
    token = crypt.decrypt_and_verify(request.env["HTTP_AUTHORIZATION"])
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
request.env["HTTP_AUTHORIZATION"]
continue
request.env["HTTP_AUTHORIZATION"]
    token = crypt.decrypt_and_verify request.env["HTTP_AUTHORIZATION"]
    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
continue
request.env.key?("HTTP_AUTHORIZATION")
continue
request.env["HTTP_AUTHORIZATION"]
request.env["Authorization"]
request.env.fetch("Authorization")
request.env
request.env.fetch("HTTP_GATEWAY_HEADERS")
request.env
request.env["HTTP_GATEWAY_HEADERS"]
request.env
request.env.headers
headers
continue
headers
request.env
continue
request.env
continue
request.env
request.env["Authorization"]
request.env["HTTP_X_USER_ID"]
exit
request.env["HTTP_X_USER_ID"]
request.env
env
headers
request
request.headers
request
headers
continue
request
continue
params[:variables]
continue
params[:variables]
continue
params[:variables]
continue
params[:variables]
variables
continue
request.headers.to_h.select { |k,v|
  ['HTTP','CONTENT','AUTHORIZATION'].any? { |s| k.to_s.starts_with? s }
}
request.headers.each { |key, value|  }
self.request.env.select {|k,v| k =~ /^HTTP_/}
self.request.env
self.request.env.select {|k,v| k =~ /^HTTP_/}
self.request.env.select {|k,v| k =~ /^Authorization/}
self.request.env.select {|k,v| k =~ /^HTTP_/}
request.env.to_h
request.env.methods
request.env
request.env["remote_adress"]
request.env
continue
request
request.env
continue
request.headers
request
request.headers['Authorization']
continue
request.headers['Authorization']
request.headers
request
continue
context[:current_user]
context
continue
request.headers
continue
request.headers
continue
request.headers
exit
request.headers
request
reques
continue
context[:current_user]
context
request
continue
request.headers
:constants
ApolloFederation::Tracing.constants[:Trace]
ApolloFederation::Tracing.constants
ApolloFederation::Tracing.:constants
ApolloFederation::Tracing.methods
ApolloFederation::Tracing.use
ApolloFederation::Tracing.methods
    result = UsersSchema.execute(query, variables: variables, context: context, operation_name: operation_name)
ApolloFederation::Tracing.should_add_traces(request.headers)
context[:tracing_enabled]
.context[:tracing_enabled] 
session
variables
query
data
 query = data.fetch(:query) 
ApolloFederation::Tracing.methods
ApolloFederation::Tracing.to_query
ApolloFederation::Tracing.methods
ApolloFederation::Tracing.to_json
ApolloFederation::Tracing
UsersSchema.to_json
UsersSchema.methods
UsersSchema
attach_trace_to_result
self
ApolloFederation::Tracing.attach_trace_to_result(request.headers)
ApolloFederation::Tracing.attach_trace_to_result(request)
ApolloFederation::Tracing.attach_trace_to_result
ApolloFederation::Tracing.methods
ApolloFederation::Tracing
continue
request.headers
continue
request.headers
request
continue
request.headers
request
continue
session
continue
User.delete_all
User.all
current_user
request.headers
