continue
request
continue
params[:variables]
continue
params[:variables]
continue
params[:variables]
continue
params[:variables]
variables
continue
request.headers.to_h.select { |k,v|
  ['HTTP','CONTENT','AUTHORIZATION'].any? { |s| k.to_s.starts_with? s }
}
request.headers.each { |key, value|  }
self.request.env.select {|k,v| k =~ /^HTTP_/}
self.request.env
self.request.env.select {|k,v| k =~ /^HTTP_/}
self.request.env.select {|k,v| k =~ /^Authorization/}
self.request.env.select {|k,v| k =~ /^HTTP_/}
request.env.to_h
request.env.methods
request.env
request.env["remote_adress"]
request.env
continue
request
request.env
continue
request.headers
request
request.headers['Authorization']
continue
request.headers['Authorization']
request.headers
request
continue
context[:current_user]
context
continue
request.headers
continue
request.headers
continue
request.headers
exit
request.headers
request
reques
continue
context[:current_user]
context
request
continue
request.headers
:constants
ApolloFederation::Tracing.constants[:Trace]
ApolloFederation::Tracing.constants
ApolloFederation::Tracing.:constants
ApolloFederation::Tracing.methods
ApolloFederation::Tracing.use
ApolloFederation::Tracing.methods
    result = UsersSchema.execute(query, variables: variables, context: context, operation_name: operation_name)
ApolloFederation::Tracing.should_add_traces(request.headers)
context[:tracing_enabled]
.context[:tracing_enabled] 
session
variables
query
data
 query = data.fetch(:query) 
ApolloFederation::Tracing.methods
ApolloFederation::Tracing.to_query
ApolloFederation::Tracing.methods
ApolloFederation::Tracing.to_json
ApolloFederation::Tracing
UsersSchema.to_json
UsersSchema.methods
UsersSchema
attach_trace_to_result
self
ApolloFederation::Tracing.attach_trace_to_result(request.headers)
ApolloFederation::Tracing.attach_trace_to_result(request)
ApolloFederation::Tracing.attach_trace_to_result
ApolloFederation::Tracing.methods
ApolloFederation::Tracing
continue
request.headers
continue
request.headers
request
continue
request.headers
request
continue
session
continue
User.delete_all
User.all
current_user
request.headers
request.headers.req
request.headers
request
continue
request.headers
request.headers["Authorization"]
continue
request.headers["Authorization"]
request.headers
session
request.headers
request
continue
request.headers['Authorization']
continue
request.headers['Authorization']
continue
request.headers['Authorization']
request.headers
continue
    return unless request.headers['Authorization']
session
request.headers
request.headers.req
request.headers
request
continue
request
request.headers
request = Rack::Request.new(env)
continue
request.headers
request
continue
exit
env
continue
request.headers.to_h
request.headers.methods
request.headers
request.headers.req
request.headers
request
continue
      request = Rack::Request.new(env)
continue
      request = Rack::Request.new(env)
env
env.to_json
env.to_H
env
ActiveResource::Base.headers
show(env)
exit
headers(env)
headers(ev)
headers
continue
headers
continue
env
request
request.headers
request
      request = Rack::Request.new(env)
env["headers"]
env
request
request["headers"]
env
request
continue
request
continue
exit
continue
        technologies.each { |technology| technology.transform_keys(&:to_sym)}
technologies
continue
current_user[:technologies]
continue
current_user[:technologies]
current_user.reload
                    current_user.update!(args)
event.data.fetch(:args)[:technologies]
event.data.fetch(:args).technologies
event.data.fetch(:args)
continue
user[:technologies][0]
user[:technologies][0]["name"]
user[:technologies][0][:name]
user[:technologies][0]
user[:technologies]
user[:technologies]["name"]
user[:technologies][:name]
user[:technologies]
[{
                name: "Ruby",
                experience: "2 years"
            }] 
            technologies: [{
                name: "Ruby",
                experience: "2 years"
            }] 
continue
cotinue
user[:technologies]
informations[:technologies]
JSON.parse(user[:technologies])
continue
exit
JSON.parse(user[:technologies])
informations[:technologies]
user[:technologies]
continue
user[:technologies]
continue
informations[:technologies]
user[:technologies]
continue
user[:technologies]
continue
args
                    current_user.update!(args.transform_keys(&:to_sym))
continue
args
                    args.transform_keys(&:to_sym)
args.transform_keys(&:to_sym)
args
args.to_s
args
continue
user[:technologies]
informations[:technologies]
continue
informations[:technologies]
user[:technologies]
exit
informations[:technologies]
user[:technologies]
continue
user.technologies
user
continue
exit
continue
self.read_attribute(:technologies).each { |technology| technology.transform_keys(&:to_sym)}
self.read_attribute(:technologies)
continue
Faker::ProgrammingLanguage.name
exit
continue
        self.read_attribute(:technologies).map{|technology| technology.deep_symbolize_keys}
        self.read_attribute(:technologies).map{|technology| techn.deep_symbolize_keys}
